
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lab 08</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="Ввод,-сортировка-и-двоичный-поиск-в-массиве-структур.">8 - Ввод, сортировка и двоичный поиск в массиве структур.</h1>
<blockquote>
<p>Лабораторная работа 8 для студентов курса “Основы программирования” 1 курса кафедры ИУ5 МГТУ им Н.Э. Баумана.</p>
</blockquote>
<h2 id="содержание">Содержание</h2>
<ul>
<li><a href="#цель-работы">Цель работы</a></li>
<li><a href="#начало-работы">Начало работы</a></li>
<li><a href="#Указания-по-выполнению-работы">Указания по выполнению работы</a></li>
<ul>
    <li><a href="#Шаги-разработки-программы:"></a>Шаги разработки программы:</li>
    <li><a href="#"></a></li>
    <li><a href="#"></a></li>
</ul>
<li><a href="#Задание">Задание</a></li>

</ul>
<h2 id="цель-работы">Цель работы</h2>
<p>Работа со структурами и массивами структур. Закрепление полученных навыков программирования на С++</li>
<ul>
    <li>Более подробно познакомиться со структурами.</li>
    <li>Работать с файлами и c-style строками, используя файловые потоки ввода/вывода и строковые функции;</li>
    <li>Закреплить навыки сортировки, поиска (бинарного и линейного)</li>
    <li>Освоить навыки работы с <strong>CMake</strong>.</li>
</ul>
<h2 id="начало-работы">Начало работы</h2>
<p>Зайдите в свою локальную директорию с репозиторием для выполнения лабораторных работ. Заберите ветку с соответствующей лабораторной работой из общего репозитория (в лабораторной работе 0 был отмечен меткой upstream):</p>
<pre><code>git pull upstream
</code></pre>
<p><strong>или</strong></p>
<pre><code>git pull upstream lab_8
</code></pre>
<p>Переключитесь на ветку с текущей лабораторной работой:</p>
<pre><code>git checkout lab_8
</code></pre>
<p>Свяжите ветку локального репозитория с вашим удаленным репозиторием:</p>
<pre><code>git push --set-upstream origin lab_8
</code></pre>
<h2 id="Задание">Задание</h2>
<p>Англо-русский словарь построен в виде массива структур <code>Dictionary</code>. Структура содержит английское слово и соответствующее ему русское слово. Для хранения записей словаря необходимо использовать динамический массив.</p>
<p>Разработать программу, которая:</p>
<ul>
    <li>обеспечивает формирование словаря (добавление и удаление записей);</li>
    <li>записывает словарь, отсортированный по английским значениям слов, в файл;</li>
    <li>обеспечивает просмотр словаря;</li>
    <li>выполняет перевод слов с английского на русский, используя для поиска слова в словаре метод двоичного поиска в отсортированном массиве;</li>
    <li>выполняет перевод слов с русского на английский, используя для поиска слов в словаре метод перебора;</li>
    <li>Программа должна обеспечивать диалог с помощью меню.</li>
</ul>
<p>Начальное число слов в словаре равно 10.</p>
<p>Для исключения проблем, связанных с вводом кириллицы, вводите русские слова латинскими буквами, например: <code>kot (cat)</code>, <code>sobaka(dog)</code> и т.п.</p>

<h2 id="Указания-по-выполнению-работы">Указания по выполнению работы</h2>
<h3>Полезная информация</h3>
<p>В программировании часто бывает так, что для представления чего-либо требуется более одной переменной. Допустим, мы хотим написать программу для хранения информации о сотрудниках компании. Нам может быть интересно отслеживать такие атрибуты, как имя сотрудника, должность, возраст, идентификатор сотрудника, идентификатор руководителя, заработную плату, день рождения, дату приёма на работу и т. д. Если бы мы использовали независимые переменные для отслеживания всей этой информации, это могло бы выглядеть примерно так:</p>
<pre><code>char* name;
char* title;
int age;
int id;
int managerId;
double wage;
int birthdayYear;
int birthdayMonth;
int birthdayDay;
int hireYear;
int hireMonth;
int hireDay;</code></pre>
<p>Однако такой подход сопряжен с рядом проблем. Во-первых, не сразу понятно, связаны ли эти переменные на самом деле (придётся читать комментарии или смотреть, как они используются в контексте). Во-вторых, теперь нужно управлять 12 переменными. Если бы мы захотели передать этого сотрудника в функцию, нам пришлось бы передать 12 аргументов (причём в правильном порядке), что привело бы к путанице в прототипах и вызовах функций. А поскольку функция может возвращать только одно значение, как функция вообще может возвращать сотрудника?
А если бы нам понадобилось больше одного сотрудника, нам пришлось бы определить ещё 12 переменных для каждого дополнительного сотрудника (каждой из которых потребовалось бы уникальное имя)! Это, очевидно, совершенно не масштабируется. Нам действительно нужен способ организовать все эти связанные данные вместе, чтобы ими было проще управлять.</p>
<p>К счастью, в C++ есть два составных типа данных, предназначенных для решения таких задач: структуры (с которыми мы познакомимся сейчас) и классы (которые мы рассмотрим вскоре). Структура (<code>struct</code>) — это программно-определяемый тип данных ( 13.1 — Введение в программно-определяемые (пользовательские) типы ), позволяющий объединять несколько переменных в один тип. Как вы скоро увидите, это значительно упрощает управление связанными наборами переменных!</p>
<p>Cтруктуры — это программно-определяемый тип, нам сначала нужно сообщить компилятору, как выглядит наш структурный тип, прежде чем мы сможем его использовать. Вот пример определения структуры для упрощённого сотрудника:</p>
<pre><code>struct Employee {
    int id {};
    int age {};
    double wage {};
};</code></pre>
<p>Ключевое <code>struct</code> слово используется для того, чтобы сообщить компилятору, что мы определяем структуру, которой мы дали имя <code>Employee</code> (поскольку определяемым программой типам обычно даются имена, начинающиеся с заглавной буквы).</p>
<p>Затем, в фигурных скобках, мы определяем переменные, которые будет содержать каждый объект <code>Employee</code>. В этом примере каждый Employeeсоздаваемый нами объект будет содержать три переменные: <code>int id</code>, <code>int age</code> и <code>double wage</code>. Переменные, входящие в структуру, называются <strong>элементами данных</strong> (или <strong>переменными-членами</strong>).</p>
<p>Чтобы использовать <code>Employee</code>тип, мы просто определяем переменную типа <code>Employee</code>:</p>
<pre><code>Employee joe {}; <i>// создание Employee структуры для Joe</i>
Employee frank {}; <i>// создание Employee структуры для Frank</i>
</code></pre>
<p>Одно из самых больших преимуществ структур заключается в том, что нам нужно создать только одно новое имя для каждой переменной структуры (имена членов фиксированы как часть определения типа структуры). В следующем примере мы создаём два <code>Employee</code> объекта: <code>joe</code> и <code>frank</code>.</p>
<pre><code>#include <iostream>

struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe {};
    joe.id = 14;
    joe.age = 32;
    joe.wage = 60000.0;

    Employee frank {};
    frank.id = 15;
    frank.age = 28;
    frank.wage = 45000.0;

    int totalAge { joe.age + frank.age };
    std::cout << "Joe и Frank: общее количество лет " << totalAge << '\n';

    if (joe.wage > frank.wage)
        std::cout << "Joe зарабатывает больше чем Frank\n";
    else if (joe.wage < frank.wage)
        std::cout << "Joe зарабатывает меньше чем Frank\n";
    else
        std::cout << "Joe and Frank зарабатывают одинаково\n";

    // Frank Фрэнк получил повышение
    frank.wage += 5000.0;

    // Сегодня день рождения joe
    ++joe.age;

    return 0;
}</code></pre>
<p>В приведённом выше примере очень легко определить, какие переменные-члены принадлежат Джо, а какие — Фрэнку. Это обеспечивает гораздо более высокий уровень организации, чем организация отдельных переменных. Более того, поскольку члены Джо и Фрэнка имеют одинаковые имена, это обеспечивает согласованность при наличии нескольких переменных одного структурного типа.</p>

<h3 id="Шаги-разработки-программы:">Шаги разработки программы:</h3>
<p><i>I. Определение состава и способа представления исходных данных, результатов и промежуточных данных</i></p>
<p>Pазмер словаря неограничен. Вам необходимо использовать динамический массив для хранения записей словаря. Также на длину слова не устанавливается ограничений. Поэтому для хранения записей словаря в оперативной памяти (ОП) можно использовать структуру <code>Dictionary</code>:</p>
<pre><code>struct Dictionary {
    char *engl;    // слово по-английски
    char *rus;     // слово по-русски
};</code></pre>
<p>Словарь хранится в текстовом файле. Элементы массива структур Dictionary будем записывать в файл последовательно, начиная с нулевого. При этом поля структуры записываются в виде отдельных строк, т.е. каждое слово должно заканчиваться символом <code>\0</code>.</p>
<p><i>II. Разработка алгоритма решения задачи</i></p>
<p>При программировании этой задачи уделим дополнительное внимание разбиению на функции и спецификации их интерфейсов. Например, логично оформить в виде функции каждую операцию со словарем (формирование, поиск, добавление и удаление элемента), поскольку они представляют собой законченные действия.</p>
<p>Будем исходить из того, что все функции должны быть независимы, чтобы изменения в одной функции не могли влиять на поведение другой. Для этого всё, что функциям необходимо получать извне, будем передавать им через параметры.</p>
<p>Прежде всего определим интерфейс нашей программы. В соответствии с заданием, кажется логичным предоставить пользователю следующие возможности:</p>
<ol>
    <li>добавление слов в словарь;</li>
    <li>удаление слов из словаря;</li>
    <li>перевод слов с английского на русский;</li>
    <li>перевод слов с русского на английский;</li>
    <li>просмотр словаря (вывод на экран словаря из ОП);</li>
    <li>вывод словаря в файл;</li>
    <li>выход.</li>
</ol>
<p><i>III. Кодирование и тестовые примеры</i></p>
<p>В этой работе удобно использовать технологию создания программы "сверху вниз": сначала отладить главную функцию, а затем постепенно добавлять к ней остальные. На месте еще не добавленных функций обычно ставятся так называемые "заглушки" (функции без реализации). Данные функции для отладки могут отображать в консоли информационное сообщение о том, что эти функции были вызваны.</p>




</body>
</html>
