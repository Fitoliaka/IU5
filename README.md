# 6 - Численное интегрирование функциии

> Лабораторная работа 6 для студентов курса “Основы программирования” 1 курса кафедры ИУ5 МГТУ им Н.Э. Баумана.

## Содержание

- [6 - Численное интегрирование функциии](#6---численное-интегрирование-функциии)
	- [Содержание](#содержание)
	- [Цель работы](#цель-работы)
	- [Начало работы](#начало-работы)
	- [Задание](#задание)
	- [Указания по выполнению работы](#указания-по-выполнению-работы)
		- [Формулы для вычисления точных значений интеграла](#формулы-для-вычисления-точных-значений-интеграла)
	- [Приложение 1: Пример вывода таблицы результатов](#приложение-1-пример-вывода-таблицы-результатов)
	- [Приложение 2: функция вывода таблицы](#приложение-2-функция-вывода-таблицы)
	- [Структуры в C++](#структуры-в-c)
	- [Передача в функцию в качестве параметров одномерных массивов и имён функций](#передача-в-функцию-в-качестве-параметров-одномерных-массивов-и-имён-функций)

## Цель работы

На примере разработки программы для численного интегрирования функции с заданной точностью методом прямоугольников и методом трапеций освоить следующие приёмы программирования:

- передача в функцию параметров «по значению» и «по адресу»;
- передача в функцию имени функции;
- передача одномерных массивов в функцию;
- объединение разнородных данных в структуру;
- использование массивов из элементов типа структура.

## Начало работы

Зайдите в свою локальную директорию с репозиторием для выполнения лабораторных работ. Заберите ветку с соответствующей лабораторной работой из общего репозитория (в лабораторной работе 0 был отмечен меткой upstream):

```bash
git pull upstream
```

**или**

```bash
git pull upstream lab_6
```

Переключитесь на ветку с текущей лабораторной работой:

```bash
git checkout lab_6
```

Свяжите ветку локального репозитория с вашим удалённым репозиторием:

```bash
git push --set-upstream origin lab_6
```

## Задание

1. **Численное интегрирование функции с заданной точностью методом прямоугольников.**

   Вычислить определённый интеграл в пределах от `a` до `b` для четырёх функций:

   - `f1(x) = x`
   - `f2(x) = sin(22x)`
   - `f3(x) = x^4`
   - `f4(x) = arctg(x)`

   Вычисление интеграла оформить в виде функции `integrationByRectangle`.

   Вычисления выполнить для пяти значений точности: `0.01`, `0.001`, `0.0001`, `0.00001` и `0.000001`.

   Исследовать быстродействие алгоритма в зависимости от подынтегральной функции и требуемой точности (быстродействие алгоритма можно оценить числом элементарных прямоугольников `n`).

   Результаты представить в виде 5 таблиц, по одной таблице для каждого значения точности. В каждой таблице выводить данные для всех четырёх функций.

   Для печати таблицы результатов использовать функцию `printTabl(resultToPrint* i_prn, int countRowOfTable);` , приведённую в приложении 2.

   Здесь `i_prn` – массив структур типа `resultToPrint` размерностью `countRowOfTable`

   Вид таблицы приведён в Приложении 1

2. **Выполнить п.1, используя для интегрирования метод трапеций.**
   Вычисление интеграла оформить в виде функции `integrationByTrapezoidal`.

   Для печати таблиц результатов использовать ту же функцию, что и в методе прямоугольников.

## Указания по выполнению работы

Алгоритм метода Дарбу-Римана аналогичен методу прямоугольников, но на каждом шаге вычисляются две суммы — верхняя (`S2`) и нижняя (`S1`):

```cpp
f1 = f(x);                    // левая граница
f2 = f(x + dx);               // правая граница

if (f1 <= f2) {
    S1 += f1 * dx;            // нижняя сумма
    S2 += f2 * dx;            // верхняя сумма
} else {
    S2 += f1 * dx;
    S1 += f2 * dx;
}
```

Вычисления прекращаются при `|S2 - S1| < eps`.

Задача вычисления определённого интеграла в пределах от `a` до `b` формулируется следующим образом: вычислить

$$
\int_{a}^{b} f(x)\,dx
$$

для подынтегральной функции `f(x)` при заданных значениях пределов интегрирования `a, b` и требуемой точности `eps`.

При численном интегрировании площадь под кривой заменяется суммой площадей «элементарных» прямоугольников с высотой, проведённой из середины основания.

Формула приближённого значения определённого интеграла представляется в виде:

$$
\sum_{i=1}^{N} f(x_i)\Delta x
$$

где:

- $$\( x_i = a + \Delta x/2 + (i-1)\Delta x \);$$
- $$\( N \)$$ — число элементарных прямоугольников.

Для уменьшения объёма вычислений множитель `Δx` следует вынести за знак суммы. Тогда в цикле нужно выполнять только суммирование, а затем полученную сумму один раз умножить на `Δx`.

Для оценки погрешности вычисления интеграла на практике используют правило Рунге. Суть правила состоит в том, что выполняют вычисление интеграла с двумя разными шагами изменения переменной ` x `, а затем сравнивают результаты и получают оценку точности. Наиболее часто используемое правило связано с вычислением интеграла дважды: с шагом `Δx` и шагом `Δx/2`.

Для методов прямоугольников и трапеций погрешность
$$ \( R_{\Delta x/2} \) $$
вычисления интеграла с шагом `Δx` оценивается следующей формулой:

$$
\left| R_{\Delta x/2} \right| = \frac{ \left| I_{\Delta x/2} - I_{\Delta x} \right| }{3}
$$

,где
	$$ \( I_{\Delta x/2} \) $$; — значение интеграла, вычисленное с шагом  `Δx/2`;
	$$ \( I_{\Delta x} \) $$;— значение интеграла, вычисленное с шагом  `Δx`.

В программе вычисления интеграла с точностью `eps` во внутреннем цикле находят значение определённого интеграла с шагом `Δx/2`. Во внешнем цикле производится сравнение значений интегралов, вычисленных с шагами `Δx` и `Δx/2` соответственно. Если требуемая точность не достигнута, то число разбиений удваивается, а в качестве предыдущего значения интеграла берут текущее и вычисление интеграла выполняется при новом числе разбиений.

Вычисление интеграла оформить в виде функции `integrationByRectangle`, формальными параметрами которой являются:

- `f` — имя интегрируемой функции,
- `a, b` — границы интервала интегрирования,
- `eps` — требуемая точность,
- `n` — число прямоугольников, при котором достигнута требуемая точность (выходной).

Функция возвращает значение интеграла.

Прототип функции:

```cpp
typedef double (*TPF)(double);
double integrationByRectangle(TPF f, double a, double b, double eps, int& n);
```

Здесь: `TPF` — тип указателя на подынтегральную функцию.

Для хранения и печати результатов вычислений используйте структуру, элементами которой являются наименование функции, значения интеграла (точное и вычисленное в виде суммы) и число «элементарных» прямоугольников `n`, при котором достигнута требуемая точность. Точные значения, полученные аналитически, нужны для оценки правильности результатов численного интегрирования.

Так как в лабораторной работе требуется выполнять вычисление интеграла для четырёх функций, для пяти значений точности для каждой функции и двумя методами, то для сокращения объёма программы следует использовать циклы, а для обеспечения возможности реализации циклов обрабатываемые данные нужно хранить в массивах (массив указателей на функции, массив значений точности, массив структур для хранения и печати результатов вычислений).

Алгоритм метода трапеций аналогичен алгоритму метода прямоугольников, только площадь элементарной трапеции вычисляется по формуле:

$$
\(S_t = \Delta x \cdot \frac{f(x) + f(x+\Delta x)}\)  {2}
$$

Прототип функции трапеций:

```cpp
double integrationByTrapezoidal(TPF f, double a, double b, double eps, int& n);
```

### Формулы для вычисления точных значений интеграла
$$
- \( \displaystyle \int_{a}^{b} x\,dx = \frac{b^2 - a^2}{2.0} \)
- \( \displaystyle \int_{a}^{b} \sin(22x)\,dx = \frac{\cos(22a) - \cos(22b)}{22.0} \)
- \( \displaystyle \int_{a}^{b} x^4\,dx = \frac{b^5 - a^5}{5.0} \)
- \( \displaystyle \int_{a}^{b} \operatorname{arctg}(x)\,dx = b\arctan(b) - a\arctan(a) - \frac{\ln(b^2+1) - \ln(a^2+1)}{2.0} \)
$$
## Приложение 1: Пример вывода таблицы результатов

![Пример вывода таблицы результатов](img/l6_printTable.png)

## Приложение 2: функция вывода таблицы

```cpp
namespace {
    const int numberOfTableColumns = 4;
    const int maxWidthOfTableColumns = 18;

    const int firstColumnWidth = 12;
    const int secondColumnWidth = 18;
    const int thirdColumnWidth = 18;
    const int fourthColumnWidth = 10;

   // Символы рамки в UTF-8
    const char* ul = "┌";   // верхний левый угол        	char(218)
    const char* ur = "┐";   // верхний правый угол      	char(191)
    const char* dl = "└";   // нижний левый угол          	char(192)
    const char* dr = "┘";   // нижний правый угол          	char(217)
    const char* vt = "│";   // вертикальная линия          	char(179)
    const char* cr = "┼";   // перекрестие                  char(194)
    const char* Td = "┬";   // Т-образный вниз            	char(197)
    const char* Tu = "┴";   // Т-образный вверх            	char(193)
    const char* Tr = "├";   // Т-образный вправо          	char(195)
    const char* Tl = "┤";   // Т-образный влево            	char(180)
}

struct resultToPrint {
    char* name;      // название функции
    double i_sum;    // численно рассчитанный интеграл
    double i_toch;   // точное значение интеграла
    int n;           // число разбиений при достижении точности
};

void printTabl(resultToPrint* i_prn, int countRowOfTable)
{
    int widthOfTableColumns[numberOfTableColumns] = {
        firstColumnWidth, secondColumnWidth,
        thirdColumnWidth, fourthColumnWidth
    };

    char* title[numberOfTableColumns];
    title[0] = new char [std::strlen("  Function  ") + 1];
    std::strcpy(title[0], "  Function  ");
    title[1] = new char [std::strlen("     Integral     ") + 1];
    std::strcpy(title[1], "     Integral     ");
    title[2] = new char [std::strlen("      IntSum      ") + 1];
    std::strcpy(title[2], "      IntSum      ");
    title[3] = new char [std::strlen("    N     ") + 1];
    std::strcpy(title[3], "    N     ");

    int size[numberOfTableColumns];
    for(int i = 0; i < numberOfTableColumns; ++i)
        size[i] = std::strlen(title[i]);

    // Верхняя рамка
    std::cout << ul << std::setfill('-');
    for(int j = 0; j < numberOfTableColumns - 1; ++j)
        std::cout << std::setw(widthOfTableColumns[j] + 3) << Td;
    std::cout << std::setw(widthOfTableColumns[numberOfTableColumns - 1] + 3) << ur << std::endl;

    // Заголовки
    std::cout << vt;
    for(int j = 0; j < numberOfTableColumns; ++j)
        std::cout << title[j] << vt;
    std::cout << std::endl;

    // Тело таблицы
    for(int i = 0; i < countRowOfTable; ++i)
    {
        std::cout << Tr << std::setfill('-');
        for(int j = 0; j < numberOfTableColumns - 1; ++j)
            std::cout << std::setw(widthOfTableColumns[j] + 3) << cr;
        std::cout << std::setw(widthOfTableColumns[numberOfTableColumns - 1] + 3)
                  << Tl << std::setfill(' ') << std::endl;

        std::cout << vt
                  << std::setw((widthOfTableColumns[0] - std::strlen(i_prn[i].name)) / 2) << ' '
                  << i_prn[i].name
                  << std::setw((widthOfTableColumns[0] - std::strlen(i_prn[i].name)) / 2) << vt;

        std::cout << std::setw(widthOfTableColumns[1]) << std::setprecision(6)
                  << i_prn[i].i_toch << vt
                  << std::setw(widthOfTableColumns[2])
                  << i_prn[i].i_sum << vt
                  << std::setw(widthOfTableColumns[3])
                  << i_prn[i].n << vt << std::endl;
    }

    // Нижняя рамка
    std::cout << dl << std::setfill('-');
    for(int j = 0; j < numberOfTableColumns - 1; ++j)
        std::cout << std::setw(widthOfTableColumns[j] + 3) << Tu;
    std::cout << std::setw(widthOfTableColumns[numberOfTableColumns - 1] + 3)
              << dr << std::setfill(' ') << std::endl;

   // Освобождение памяти
    for (int i = 0; i < numberOfTableColumns; ++i)
        delete[] title[i];
}

## Структуры в C++


## Передача в функцию в качестве параметров одномерных массивов и имён функций



---
